-- LocalScript (Xeno, Synapse vb.)

local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")
local uis = game:GetService("UserInputService")

-- Vuruş remote'unu bul (oyuna göre değişebilir)
local remote = game:GetService("ReplicatedStorage"):FindFirstChild("Parry") 
        or game:GetService("ReplicatedStorage"):FindFirstChild("Swing")
        or game:GetService("ReplicatedStorage"):FindFirstChild("Hit")
        or game:GetService("ReplicatedStorage"):FindFirstChild("Block")

-- Eğer remote bulunamazsa, uyarı ver
if not remote then
    warn("Vuruş remote'u bulunamadı! Lütfen oyuna göre düzenle.")
end

-- Ana koruma küresi (görsel)
local function createProtectionSphere()
    local character = player.Character
    if not character then return nil end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end

    -- Ana küre (yarı saydam, sadece dış hatları görünsün diye çok saydam yapalım)
    local sphere = Instance.new("Part")
    sphere.Name = "KorumaKuresi"
    sphere.Size = Vector3.new(2, 2, 2) -- başlangıç boyutu
    sphere.Shape = Enum.PartType.Ball
    sphere.CFrame = rootPart.CFrame
    sphere.Anchored = true
    sphere.CanCollide = false
    sphere.Transparency = 0.7
    sphere.BrickColor = BrickColor.new("White")
    sphere.Material = Enum.Material.Neon
    sphere.Parent = workspace

    -- Dönen halkalar (3 tane, farklı eksenlerde)
    local rings = {}
    for i = 1, 3 do
        local ring = Instance.new("Part")
        ring.Name = "Halka" .. i
        ring.Size = Vector3.new(2, 0.2, 0.2) -- ince
        ring.Shape = Enum.PartType.Cylinder
        ring.Anchored = true
        ring.CanCollide = false
        ring.Transparency = 0.3
        ring.BrickColor = BrickColor.new("White")
        ring.Material = Enum.Material.Neon
        ring.Parent = workspace
        table.insert(rings, ring)
    end

    -- Döndürme animasyonu
    local angle = 0
    local connection
    connection = runService.RenderStepped:Connect(function()
        if not character or not character.Parent or not rootPart or not rootPart.Parent then
            if sphere then sphere:Destroy() end
            for _, r in ipairs(rings) do if r then r:Destroy() end end
            connection:Disconnect()
            return
        end

        angle = angle + 0.03
        if angle > math.pi*2 then angle = 0 end

        -- Ana küreyi rootPart'ın üzerinde tut
        sphere.CFrame = rootPart.CFrame * CFrame.new(0, 1, 0)

        -- Halkaları farklı eksenlerde döndür
        if rings[1] then
            rings[1].CFrame = rootPart.CFrame * CFrame.new(0, 1, 0) * CFrame.Angles(0, angle, 0) * CFrame.new(0, 0, sphere.Size.X/2)
        end
        if rings[2] then
            rings[2].CFrame = rootPart.CFrame * CFrame.new(0, 1, 0) * CFrame.Angles(angle, 0, 0) * CFrame.new(0, 0, sphere.Size.X/2)
        end
        if rings[3] then
            rings[3].CFrame = rootPart.CFrame * CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, angle) * CFrame.new(0, sphere.Size.Y/2, 0)
        end

        -- Boyutu güncelle
        sphere.Size = sphere.Size  -- aslında boyutu aşağıdaki döngüde değişecek
        for _, r in ipairs(rings) do
            r.Size = Vector3.new(sphere.Size.X, 0.2, 0.2)
        end
    end)

    return sphere, rings
end

local sphere, rings = createProtectionSphere()

-- En yakın topu bul ve boyutu ayarla
local function updateSphereSize()
    local character = player.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local closestBall = nil
    local closestDist = math.huge

    -- Workspace'teki topları bul (isimlerinde "Ball" geçen veya hızlı hareket eden)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Part") and (obj.Name:find("Ball") or obj.Name:find("Projectile") or obj.Velocity.Magnitude > 10) then
            local dist = (obj.Position - rootPart.Position).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestBall = obj
            end
        end
    end

    if closestBall and sphere then
        -- Mesafeye göre boyut ayarla: yakın top = büyük küre (max 20), uzak top = küçük küre (min 5)
        local targetSize = math.clamp(20 - closestDist, 5, 20)
        sphere.Size = Vector3.new(targetSize, targetSize, targetSize)

        -- Eğer top çok yakınsa ve remote varsa vur
        if closestDist < targetSize and remote then
            remote:FireServer(closestBall)
            print("Top vuruldu!", closestBall.Name)
        end
    end
end

-- Her frame'de kontrol et
runService.RenderStepped:Connect(updateSphereSize)

-- Karakter değişince yeniden oluştur
player.CharacterAdded:Connect(function()
    if sphere then sphere:Destroy() end
    for _, r in ipairs(rings or {}) do if r then r:Destroy() end end
    sphere, rings = createProtectionSphere()
end)
